# 요셉 학번202130218
# 4월 5일 강의
메소드의 배열리턴
배열 리턴
    배열의 래퍼런스만 리턴(배열 전체가 리턴되는 것이 아님)

메소드의 리턴타입
    리턴하는 배열 타입과 리턴 받는 배열 타입 일치
    리턴 타입에 배열의 크기를 지정하지 않음

자바의 예외 처리
예외
    실행 중 오동작이나 결과에 악영향을 미치는 예상치 못한 상황 발생
    자바에서는 실행 중 발생하는 에러를 예외로 처리
실행 중 예외가 발생하면
    자바 플랫폼은 응용프로그램이 예외를 처리하도록 호출
    응용프로그램이 예외를 처리하지 않으면 프로그램 강제 종료 시킴
예외 발생 경우
    정수를 0으로 나누는 경우
    배열의 크기보다 큰 인덱스로 배열의 원소를 접근하는 경우
    정수를 읽는 코드가 실행되고 있을 때 사용자가 문자를 입력한 경우

예외처리
    발생한 예외에 대해 개발자가 작성한 프로그램 코드에서 대응하는 것 
    try=catch-finally문 사용
    finally 블록은 생략가능

자바의 예외 클래스
    자바 플랫폼은 응용프로그램이 실행 중 오류를 탐지할 수 있도록 많은 예외를 클래스 형태로 제공

세상 모든 것이 객체다
실세계 객체의 특징
    객체마다 고유한 특성(state)와 행동(behavior)를 가짐
    다른 객체들과 정보를 주고 받는 등, 상호작용하면서 살아감
컴퓨터  프로그램에서 객체 사례
    테트리스 게임의 각 블록들
    한글 프로그램의 메뉴나 버튼들

자바의 객체 지향 특성:캡슐화
    캡슐화:객체를 캡슐로 싸서 내부를 볼 수 없게 하는 것 
    객체의 가장 본질적인 특징
    외부인의 접근으로부터 객체보호
자바의 캡슐화
    클래스(class):객체 모양을 선언한 틀(캡슐화하는 틀)
    객체:생성된 실체(instance)
    클래스 내에  메소드와 필드 구현

자바의 객체 지향 특성:상속
상속
    상위개체의 속성이 하위 개체에 물려짐
    하위 개체가 상위 개체의 속성을 모두 가지는 관계

자바 상속
상위 클래스의 멤버를 하위 클래스가 물려받음
    상위클래스:수퍼클래스
    하위클래스:서브클래스, 수퍼 클래스 코드의 재사용, 새로운 특성 추가 기능

다형성
같은 이름의 메소드가 클래스 혹은 객체에 따라 다르게 구현되는 것
다형성 사례
    메소드 오버로딩:한 클래스 내에서 같은 이름이지만 다르게 작동하는 여러 메소드
    메소드 오버라이딩:슈퍼클래스의 메소드를 동일한 이름으로 서브 클래스마다 다르게 구현

1.소프트웨어의 생산성 향상
컴퓨터 산업 발전에 따라 소프트웨어의 생명 주기(life cycle) 단축
    소프트웨어를 빠른 속도로 생산할 필요성 증대
객체 지향 언어
    상속, 다형성, 객체, 캡슐화 등 소프트웨어 재사용을 위한 여러 장치 내장
    소프트웨어 재사용과 부분 수정 빠름
    소프트웨어를 다시 만드는 부담 대폭 줄임
    소프트웨어 생산성 향상
2.실세계에 대한 쉬운 모델링
초기 프로그래밍
    수학 계산/통계 처리를 하는 등 처리 과정, 계산 절차 중요
현대 프로그래밍
    컴퓨터가 산업 전반에 활용
    실세계에서 발생하는 일을 프로그래밍
    실세계에서는 절차나 과정보다 물체(객체)들의 상호 작용으로 묘사하는 것이 용이
객체 지향 언어
    실세계의 일을 보다 쉽게 프로그래밍하기 위한 객체 중심적 언어

절차 지향 프로그래밍
    작업 순서를 표현하는 컴퓨터 명령 집합
    함수들의 집합으로 프로그램 작성
객체 지향 프로그래밍
    컴퓨터가 수행하는 작업을 객체들간의 상호 작용으로 표현
    클래스 혹은 객체들의 집합으로 프로그램 작성

클래스
    객체의 속성(state)과 행위(behavior) 선언
    객체의 설계도 혹은 틀
객체
클래스의 틀로 찍어낸 실체
    프로그램 실행 중에 생성되는 실체
    메모리 공간을 갖는 구체적인 실체
    인스턴스(instance)라고도 부름
사례
클래스: 소나타자동차, 객체: 출고된 실제 소나타 100대
클래스: 벽시계, 객체: 우리집 벽에 걸린 벽시계들
클래스: 책상, 객체: 우리가 사용중인 실제 책상들

자바 클래스 구성
클래스
    class 키워드로 선언
    멤버 : 클래스 구성 요소
        필드(멤버 변수)와 메소드(멤버 함수)
    클래스에 대한 public 접근 지정 : 다른 모든 클래스에서 클래스 사용 허락
    멤버에 대한 public 접근 지정 : 다른 모든 클래스에게 멤버 접근 허용

생성자 개념과 목적
생성자
    객체가 생성될 때 초기화 목적으로 실행되는 메소드 
    객체가 생성되는 순간에 자동 호출    

생성자의 특징
    생성자의 이름은 클래스 이름과 동일
    생성자는 여러 개 작성 가능(생성자 중복)
    생성자는 객체 생성시 한 번만 호출
        자바에서는 객체 생성은 반드시 new 연산자로 함
    
    생성자의 목적은 객체 생성 시 초기화
    생성자는 리턴 타입을 지정할 수 없음

기본생성자
    매개 변수 없고, 아무 작업 없이 단순 리턴하는 생성자
    디폴트 생성자라고도 불림

기본 생성자가 자동 생성되지 않는 경우
클래스에 생성자가 하나도 선언되어 있지 않을 때
    컴파일러에 의해 기본 생성자 자동 생성

기본 생성자가 자동 생성되지 않는 경우
클래스에 생성자가 선언되어 있는 경우
    컴파일러는 기본 생성자를 자동 생성해 주지 않는다

this 레퍼런스
this
    객체 자신에 대한 래퍼런스
        컴파일러에 의해 자동관리, 개발자는 사용하기만 하면 됨
        this.멤버 형태로 멤버를 접근할 때 사용

this()로 다른 생성자 호출
    같은 클래스의 다른 생성자 호출
    생성자 내에서만 사용가능
    생성자 코드의 제일 처음에 있어야함

객체배열
자바의 객체 배열
    객체에 대한 레퍼런스 배열임
자바의 객체 배열 만들기 3단계
1.배열 레퍼런스 변수선언
2.레퍼런스 배열 생성
3.배열의 각 원소 객체 생성

메소드
    메소드는 C/C++의 함수와 동일
    자바의 모든 메소드는 반드시 클래스 안에 있어야 함(캡슐화 원칙)
메소드 형식
    접근 지정자
        다른 클래스에서 메소드를 접근할 수 있는지 여부 선언
        public. private, protected, 디폴트(접근 지정자 생략)
    리턴 타입
        메소드가 리턴하는 값의 데이터 타입

메소드 오버로딩
오버로딩
    한 클래스 내에서 두 개 이상의 이름이 같은 메소드 작성
        메소드 이름이 동일하여야 함
        매개 변수의 개수가 서로 다르거나, 타입이 서로 달라야함
        리턴 타입은 오버로딩과 관련 없음
    
객체 소멸
    new에 의해 할당 받은 객체와 배열 메모리를 자바 가상 기계로 되돌려 주는 행위
    소멸된 객체 공간은 가용 메모리에 포함
자바에서 사용자 임의로 객체 소멸 안됨
    자바는 객체 소멸 연산자 없음
        객체 생성 연산자:new
    객체 소멸은 자바 가상 기계의 고유한 역할
    자바 개발자에게는 매우 당황스러운 기능
        C/C++에서는 할당 받은 객체를 개발자가 프로그램 내에서 삭제해야 함
        C/C++의 프로그램 작성을 어렵게 만드는 요인
        자바에서는 사용하지 않는 객체나 배열을 돌려주는 코딩 책임으로부터 개발자 해방

가비지
    가리키는 레퍼런스가 하나도 없는 객체
        더 이상 접근할 수 없어 사용할 수 없게 된 메모리
가비지 컬렉션
    자바 가상 기계의 가비지 컬렉터가 자동으로 가비지 수집, 반환

가비지의 컬렉션
    자바 가상 기계가 가비지 자동 회수
        가용 메모리 공간이 일정 이하로 부족해 질 때
        가비지를 수거하여 가용 메모리 공간으로 확보
    가비지 컬렉터(garbage collector)에 의해 자동 수행
강제 가비지 컬렉션 강제 수행
    System 또는 Runtime 객체의 gc() 메소드 호출
        이 코드는 자바 가상 기계에 강력한 가비지 컬렉션 요청
        그러나 자바 가상 기계가 가비지 컬렉션 시점을 전적으로 판단

자바의 패키지 개념
패키지
    상호 관련 있는 클래스 파일(컴파일된 .class)을 저장하여 관리하는 디렉터리
    자바 응용프로그램은 하나 이상의 패키지로 구성

접근 지정자
자바의 접근 지정자
    4가지
        private, protected, public, 디폴트(접근지정자 생략)
접근 지정자의 목적
    클래스나 일부 멤버를 공개하여 다른 클래스에서 접근하도록 허용
    객체 지향 언어의 캡슐화 정책은 멤버를 보호하는 것
        접근 지정은 캡슐화에 묶인 보호를 일부 해제할 목적

클래스 접근 지정 
    다른 클래스에서 사용하도록 허용할 지 지정
    public 클래스
        다른 모든 클래스에게 접근 허용
    디폴트 클래스(접근지정자 생략)
        package-private라고도 함
        같은 패키지의 클래스에만 접근 허용

멤버 접근 지정
    public 멤버
        패키지에 관계 없이 모든 클래스에게 접근 허용
    private 멤버
        동일 클래스 내에만 접근 허용
        상속 받은 서브 클래스에서 접근 불가
    protected 멤버
        같은 패키지 내의 다른 모든 클래스에게 접근 허용
        상속 받은 서브 클래스는 다른 패키지에 있어도 접근 가능
    디폴트(default) 멤버
        같은 패키지 내의 다른 클래스에게 접근 허용

static 멤버
    객체 생성과 non-static 멤버의 생성
        non-static 멤버는 객체가 생성될 때, 객체마다 생긴다
        static 멤버는 클래스당 하나만 생성
        객체들에 의해 공유됨
## 3월 29일 강의 
식별자, 문자열, 변수와 선언, 리터럴, 식과 연산자, 연산
반복문과 배열 등을 배움.
## 3월 22일 강의
var 키워드
java 10부터 도입
기존의 변수 선언 방식 : 변수의 타입 반드시 지정
var 키워드
타입을 생략하고 변수 선언 가능
컴파일러가 추론하여 변수 타입 결정
변수 선언 시 초깃값이 주어지지 않으면 컴파일 오류
var는 지역 변수 선언에만 한정
## 3월 15일 강의
내용 정리

이번에는 올리지않음.
