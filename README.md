# 요셉 학번202130218

# 4월 19일 강의

추상 클래스
추상 메소드
    abstract로 선언된 메소드, 메소드의 코드는 없고 원형만 선언
추상 클래스
    추상 메소드를 가지며, abstract로 선언된 클래스
     추상 메소드 없이, abstract로 선언한 클래스

추상 클래스의 인스턴스 생성 불가
    추상 클래스는 온전한 클래스가 아니기 때문에 인스턴스를 생성할 수 없음

추상 클래스의 상속과 구현
추상 클래스 상속
    추상 클래스를 상속받으면 추상 클래스가 됨
    서브 클래스도 abstract로 선언해야 함
추상 클래스 구현
    서브 클래스에서 슈퍼 클래스의 추상 메소드 구현(오버라이딩)
    추상 클래스를 구현한 서브 클래스는 추상 클래스 아님

추상 클래스의 목적
    상속을 위한 슈퍼 클래스로 활용하는 것
    서브 클래스에서 추상 메소드 구현
    다향성 실현

자바의 인터페이스
    클래스가 구현해야 할 메소드들이 선언되는 추상형
    인터페이스 선언
        interface 키워드로 선언
        Ex) public interface SerialDriver {...}
자바 인터페이스에 대한 변화
    java 7까지
        인터페이스는 상수와 추상 메소드로만 구성
    Java 8부터
        상수와 추상메소드 포함
        default 메소드 포함 (Java 8)
        private 메소드 포함 (Java 9)
        static 메소드 포함 (Java 9)
    여전히 인터페이스에는 필드(멤버 변수) 선언 불가

인터페이스의 구성 요소들의 특징
인터페이스의 구성 요소들
    상수
        public만 허용, public static final 생략
    추상 메소드
        public abstract 생략 가능
    default 메소드
        인터페이스에 코드가 작성된 메소드
        인터페이스를 구현하는 클래스에 자동 상속
        public 접근 지정만 허용. 생략 가능
    private 메소드
        인터페이스 내에 메소드 코드가 작성되어야 함
        인터페이스 내에 있는 다른 메소드에 의해서만 호출 가능
    static 메소드
        public, private 모두 지정 가능. 생략하면 public
    
인터페이스 상속
인터페이스 간에 상속 가능
    인터페이스를 상속하여 확장된 인터페이스 작성 가능
    extends 키워드로 상속 선언
인터페이스 다중 상속 허용

인터페이스 구현
인터페이스의 추상 메소드를 모두 구현한 클래스 작성
    implements 키워드 사용
    여러 개의 인터페이스 동시 구현 가능
인터페이스 구현 사례
    PhoneInterface 인터페이스를 구현한 SamsungPhone 클래스
    SamsungPhone 클래스는 PhoneInterface의 default 메소드상속

자바의 패키지와 모듈이란?
패키지(package)
    서로 관련된 클래스와 인터페이스를 컴파일한 클래스 파일들을 묶어 놓은 디렉터리
    하나의 응용프로그램은 한 개 이상의 패키지로 작성
    패키지는 jar 파일로 압축할 수 있음
모듈(module)
    여러 패키지와 이미지 등의 자원을 모아 놓은 컨테이너
    하나의 모듈을 하나의 .jmod 파일에 저장
Java 9부터 모듈화 도입
    플랫폼의 모듈화
        Java 9부터 자바 API의 모든 클래스들(자바 실행 환경)을 패키지 기반에서 모듈들로 완전히 재구성
    응용프로그램의 모듈화
        클래스들은 패키지로 만들고, 다시 패키지를 모듈로 만듬
        모듈 프로그래밍은 어렵고 복잡. 기존 방식으로 프로그램 작성

자바의 모듈화의 목적
모듈화의 목적
    Java 9부터 자바 API를 여러 모듈(99개)로 분할
        Java 8까지는 rt.jar의 한 파일에 모든 API 저장
    응용프로그램이 실행할 때 꼭 필요한 모듈들로만 실행 환경 구축
        메모리 자원이 열악한 작은 소형 기기에 꼭 필요한 모듈로 구성된 작은 크기의 실행 이미지를 만들기 위함
묘듈의 현실
    java 9부터 전면적으로 도입
    복잡한 개념
    큰 자바 응용프로그램에는 개발, 유지보수 등에 적함
    현실적으로 모듈로 나누어 자바 프로그램을 작성할 필요 없음

패키지 사용하기, import문
다른 패키지에 작성된 클래스 사용
    import를 이용하지 않는 경우
        소스에 클래스 이름의 완전 경로명 사용
    필요한 클래스만 import
        소스 시작 부분에 클래스의 경로명 import
        import 패키지.클래스
        소스에는 클래스 명만 명시하면 됨
    
    패키지 전체를 import
        소스 시작 부분에 패키지의 경로명.*import
        import 패키지.*
        소스에는 클래스 명만 명시하면 됨
        import java.util.*;

패키지 만들기
클래스 파일(.class)이 저장되는 위치는?
    클래스나 인터페이스가 컴파일되면 클래스 파일(.class) 생성
    클래스 파일은 패키지로 선언된 디렉터리에 저장
패키지 선언
    소스 파일의 맨 앞에 컴파일 후 저장될 패키지 지정
        package 패키지명;

디폴트 패키지
    package 선언문이 없는 자바 소스 파일의 경우
        컴파일러는 클래스나 인터페이스를 디폴트 패키지에 소속시킴
        디폴트 패키지
            현재 디렉터리

모듈 개념
모듈
    java 9에서 도입된 개념
    패키지와 이미지 등의 리소스를 담은 컨테이너
    모듈 파일(.jmod)로 저장

자바 플랫폼의 모듈화
자바 플랫폼
    자바의 개발 환경(jdk)과 자바의 실행 환경(JRE)을 지칭
        Java SE(자바 API) 포함
    자바 API의 모든 클래스가 여러 개의 모듈로 재구성됨
    모듈 파일은 JDK의 jmods 디렉터리에 저장하여 배포
모듈 파일로부터 모듈을 푸는 명령

모듈 기반의 자바 실행 환경
자바 실행 환경
    JRE: 디폴트 자바 실행 환경
        자바 모듈(컴파일된 자바 API 클래스들), 자바 가상 기계 등으로 구성

자바 모듈화의 목적
    가장 큰 목적
        자바 컴포넌트들을 필요에 따라 조립하여 사용하기 위함
        컴퓨터 시스템의 불필요한 부담 감소
            세밀한 모듈화를 통해 필요 없는 모듈이 로드되지 않게 함
            소형 IoT 장치에도 자바 응용프로그램이 실행되고 성능을 유지하게 함

JDK의 주요 패키지
    java.lang
        스트링, 수학 함수, 입출력 등 자바 프로그래밍에 필요한 기본적인 클래스와 인터페이스
        자동으로 import 됨 - import 문 필요 없음
    java.util
        날짜, 시간, 벡터, 해시맵 등과 같은 다양한 유틸리티 클래스와 인터페이스 제공
    java.io
    키보드, 모니터, 프린터, 디스크 등에 입출력을 할 수 있는 클래스와
    인터페이스 제공
    java.awt
    GUI 프로그램을 작성하기 위한 AWT 패키지
    javax.swing
    GUI 프로그래밍을 작성하기 위한 스윙 패키지

Object 클래스
특징
    모든 자바 클래스는 반드시 Object를 상속받도록 자동 컴파일 
        모든 클래스의 수퍼 클래스
        모든 클래스가 상속받는 공통 메소드 포함

객체 속성
Object 클래스는 객체의 속성을 나타내는 메소드 제공
    hashCode() 메소드
        객체의 해시코드 값을 리턴하며, 객체마다 다름
    getClass() 메소드
        객체의 클래스 정보를 담은 Class 객체 리턴
        Class 객체의 getName() 메소드는 객체의 클래스 이름 리턴
    to String() 메소드
        객체를 문자열로 리턴

toString() 메소드, 객체를 문자열로 변환
각 클래스는 toString()을 오버라이딩하여 자신만의 문자열 리턴 가능
    객체를 문자열로 반환
    원형
        public String toString();
컴파일러에 의한 toString() 자동 변환
    ‘객체 + 문자열’ -> ‘객체.toString() + 문자열’로 자동 변환
    객체를 단독으로 사용 하는 경우 -> 객체.toString()으로 자동변환

객체 비교(==)와 equals() 메소드
== 연산자
    객체 레퍼런스 비교
boolean equals(Object obj)
    두 객체의 내용물 비교
    객체의 내용물을 비교하기 위해 클래스의 멤버로 작성

Wrapper 클래스
    자바의 기본 타입을 클래스화한 8개 클래스를 통칭
용도
    객체만 사용할 수 있는 컬렉션 등에 기본 타입의 값을 사용하기 위해 -> Wrapper 객체로 만들어 사용

주요 메소드 
    가장 많이 사용하는 integer 클래스의 주요 메소드
        다른 Wrapper 클래스의 메소드는 이와 유사

Wrapper 활용
    Wrapper 객체로부터 기본 타입 값 알아내기
    문자열을 기본 데이터 타입으로 변환
    기본 타입을 문자열로 변환

박싱과 언박싱
박싱
    기본 타입의 값을 Wrapper 객체로 변환하는것
언박싱
    Wrapper 객체에 들어 있는 기본 타입의 값을 뺴내는 것
    박싱의 반대
자동 박싱과 자동 언박싱
    JDK 1.5부터 박싱과 언박싱은 자동으로 이루어지도록 컴파일됨

String의 생성과 특징
String
    String 클래스는 문자열을 나타냄
    스트링 리터럴(문자열 리터럴)은 String 객체로 처리됨
    스트링 객체의 생성 사례

스트링 리터럴과 new String()
스트링 리터럴
    자바 가상 기계 내부에서 리터럴 테이블에 저장되고 관리됨
    응용프로그램에서 공유됨
        스트링 리터럴 사례)String s = "hello";

new String()으로 생성된 스트링
    스트링 객체는 힙에 생성
    스트링은 공유되지 않음

스트링 객체의 주요 특징
스트링 객체는 수정 불가능
    리터럴 스트링이든 new String()을 생성했든 객체의 문자열 수정 불가능
스트링 비교
    두 스트링을 비교할 떄 반드시 equals()를 사용하여야 함
    equals()는 내용을 비교하기 떄문

String 활용
스트링 비교, equals()와 compareTo()
    스트링 비교에 == 연산자 절대 사용 금지
    equals()
        스트링이 같으면 true, 아니면 false 리턴
    int compareTo(String anotherString)
        문자열이 같으면 0 리턴
        이 문자열이 anotherString 보다 사전에 먼저 나오면 음수 리턴
        이 문자열이 anotherString 보다 사전에 나중에 나오면 양수 리턴

String 활용
    공백 제거,String trim()
        키보드나 파일로부터 스트링을 입력 시, 스트링 앞 뒤 공백이 끼는 경우가 많다. -> trim()을 이용하면 스트링 앞 뒤에 있는 공백 제거

StringBuffer 클래스
    가변 스트링을 다루는 클래스
    StringBuffer 객체 생성
    String 클래스와 달리 문자열 변경 가능
        가변 크기의 버퍼를 가지고 있어 문자열 수정 가능
        문자열의 수정이 많은 작업에 적합

StringTokenizer 클래스
    구분 문자를 기준으로 문자열을 분리하는 클래스
        구분 문자(delimiter) : 문자열을 구분할 때 사용되는 문자
        토큰(token) : 구분 문자로 분리된 문자열

Math 클래스
    기본 산술 연산 메소드를 제공하는 클래스
    모든 메소드는 static으로 선언  
        클래스 이름으로 호출 가능
    Math.random() 메소드로 난수 발생
        random()은 0보다 크거나 같고 1.0보다 작은 실수 난수 발생
        1에서 100까지의 랜덤 정수 10개를 발생시키는 코드 사례
        
# 4월 12일 강의
static 멤버
객체 생성과 non-static 멤버의 생성
    non-static 멤버는 객체가 생성될 때, 객체마다 생긴다

static 멤버의 생성
static 멤버는 클래스당 하나만 생성
객체들에 의해 공유됨

static 멤버 사용
클래스 이름으로 접근 가능
객체의 멤버로 접근 가능
non-static 멤버는 클래스 이름으로 접근 안 됨

static의 활용
전역 변수와 전역 함수를 만들 때 활용
공유 멤버를 만들고자 할 때
    static으로 선언한 멤버는 클래스의 객체들 사이에 공유

static 메소드의 제약 조건 1
    static 메소드는 오직 static 멤버만 접근 가능
객체가 생성되지 않은 상황에서도 static 메소드는 실행될 수 있기 때
문에, non-static 멤버 활용 불가
non-static 메소드는 static 멤버 사용 가능

static 메소드의 제약 조건 2
    static 메소드는 this 사용불가
static 메소드는 객체 없이도 사용 가능하므로, this 레퍼런스 사용할
수 없음

final 클래스와 메소드
final 클래스 - 더 이상 클래스 상속 불가능
final 메소드 - 더 이상 오버라이딩 불가능

final 필드
final 필드, 상수 선언
    상수를 선언할 때 사용
    상수 필드는 선언 시에 초기 값을 지정하여야 한다
    상수 필드는 실행 중에 값을 변경할 수 없다

클래스 상속과 객체
상속 선언
    extends 키워드로 선언
        부모 클래스를 물려받아 확장한다는 의미
    부모 클래스 -> 슈퍼클래스(super class)
    자식 클래스 -> 서브클래스(sub class)
        ColorPoint는 Point를 물려 받으므로 Point에 선언된 필드와 메소드 선언 필요없음

자바 상속의 특징
클래스 다중 상속(multiple inheritance) 불허
    c++는 다중 상속 가능
        c++는 다중 상속으로 멤버가 중복생성되는 문제 있음
    자바는 인터페이스(interface)의 다중 상속 허용
모든 자바 클래스는 묵시적으로 Object클래스 상속받음
    java.lang.Object는 클래스는 모든 클래스의 슈퍼클래스

슈퍼 클래스의 멤버에 대한 서브 클래스의 접근
슈퍼 클래스의 private 멤버
    서브 클래스에서 접근할 수 없음
슈퍼 클래스의 디폴트 멤버
    서브 클래스가 동일한 패키지에 있을 때, 접근 가능
슈퍼 클래스의 public 멤버
    서브 클래스는 항상 접근 가능

슈퍼 클래스의 protected 멤버
    같은 패키지 내의 모든 클래스 접근 허용
    패키지 여부와 상관없이 서브 클래스는 접근 가능
    상속되는 서브 클래스(같은 패키지든 다른 패키지든 상관 없음)에게 허용

서브 클래스/슈퍼 클래스의 생성자 호출과 실행
서브 클래스의 객체가 생성될 때
    슈퍼클래스 생성자와 서브 클래스 생성자 모두 실행
    호출 순서
        서브 클래스의 생성자 먼저 호출,
        서브 클래스의 생성자는 실행 전 슈퍼 클래스 생성자 호출
    실행 순서
        슈퍼 클래스의 생성자가 먼저 실행된 후 서브 클래스의 생성자 실행

서브 클래스와 슈퍼 클래스의 생성자 선택
    슈퍼 클래스와 서브 클래스
        각각 여러 개의 생성자 작성 가능
서브 클래스의 객체가 생성될 때
    슈퍼 클래스 생성자 1 개와 서브 클래스 생성자 1개가 실행
서브 클래스의 생성자와 슈퍼 클래스의 생성자가 결정되는 방식
1. 개발자의 명시적 선택
    서브 클래스 개발자가 슈퍼 클래스의 생성자 명시적 선택
    super() 키워드를 이용하여 선택
2. 컴파일러가 기본생성자 선택
    서브 클래스 개발자가 슈퍼 클래스의 생성자를 선택하지 않는 경우
    컴파일러가 자동으로 슈퍼 클래스의 기본 생성자 선택

super()로 슈퍼 클래스의 생성자 명시적 선택
super()
    서브 클래스에서 명시적으로 슈퍼 클래스의 생성자 선택 호출
    사용 방식
        super(parameter);
        인자를 이용하여 슈퍼 클래스의 적당한 생성자 호출
        반드시 서브 클래스 생성자 코드의 제일 첫 라인에 와야 함

업캐스팅
    서브 클래스의 레퍼런스를 슈퍼 클래스 레퍼런스에 대입
    슈퍼 클래스 레퍼런스로 서브 클래스 객체를 가리키게 되는 현상
        슈퍼클래스 레퍼런스로 객체 내의 슈퍼클래스의 멤버만 접근가능

다운캐스팅
    슈퍼 클래스 레퍼런스 서브 클래스 레퍼런스에 대입
    업캐스팅된 것을 다시 원래대로 되돌리는 것
    반드시 명시적 타입 변환지정

업캐스팅 레퍼런스로 객체 구별?
업캐스팅된 레퍼런스로는 객체의 실제 타입을 구분하기 어려움
    슈퍼 클래스는 여러 서브 클래스에 상속되기 때문
    예) 아래의 클래스 계층 구조에서, p가 가리키는 객체가 Person 객체인지, Student 객체인지, Professor 객체인지 구분하기 어려움

instanceof 연산자 사용
instanceof 연산자
    레퍼런스가 가리키는 객체의 타입 식별

메소드 오버라이딩의 개념 
메소드 오버라이딩
    서브 클래스에서 슈퍼 클래스의 메소드 중복작성
    슈퍼 클래스의 메소드 무력화, 항상 서브 클래스에 오버라이딩한 메소드가 실행되도록 보자오딤
    메소드 무시하기로 번역되기도함
오버라이딩 조건
    슈퍼 클래스 메소드의 원형(메소드 이름, 인자 타입 및 개수, 리턴 타입) 동일하게 작성

오버라이딩의 목적, 다형성 실현
    하나의 인터페이스(같은 이름)에 서로 다른 구현
    슈퍼 클래스의 메소드를 서브 클래스에서 각각 목적에 맞게 다르게 구현
    사례
        Shape의 draw() 메소드를 Line, Rect, Circle 에서 오버라이딩하여 다르게 구현

super 키워드로 슈퍼 클래스의 멤버 접근
super   
    슈퍼 클래스의 멤버를 접근할 때 사용되는 레퍼런스
    super.슈퍼클래스의 멤버
    서브 클래스에서만 사용
    슈퍼클래스의 필드접근
    슈퍼클래스의 메소드 호출시
    super로 이루어지는 메소드 호출 : 정적 바인딩
##3월 29일 강의 
식별자, 문자열, 변수와 선언, 리터럴, 식과 연산자, 연산
반복문과 배열 등을 배움.
## 3월 22일 강의
var 키워드
java 10부터 도입
기존의 변수 선언 방식 : 변수의 타입 반드시 지정
var 키워드
타입을 생략하고 변수 선언 가능
컴파일러가 추론하여 변수 타입 결정
변수 선언 시 초깃값이 주어지지 않으면 컴파일 오류
var는 지역 변수 선언에만 한정
## 3월 15일 강의
내용 정리

이번에는 올리지않음.
